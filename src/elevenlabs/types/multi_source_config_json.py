# This file was auto-generated by Fern from our API Definition.

import typing

import pydantic
from ..core.pydantic_utilities import IS_PYDANTIC_V2
from ..core.unchecked_base_model import UncheckedBaseModel
from .merging_strategy import MergingStrategy
from .source_config_json import SourceConfigJson


class MultiSourceConfigJson(UncheckedBaseModel):
    """
    JSON-serializable multi-source retrieval configuration.

    This can be passed as JSON in tool configurations for full control.
    """

    source_names: typing.Optional[typing.List[str]] = pydantic.Field(default=None)
    """
    List of source names to use (e.g., ['chunks', 'products'])
    """

    source_overrides: typing.Optional[typing.List[SourceConfigJson]] = pydantic.Field(default=None)
    """
    Per-source parameter overrides
    """

    merging_strategy: typing.Optional[MergingStrategy] = pydantic.Field(default=None)
    """
    How to merge results from multiple sources
    """

    final_top_k: typing.Optional[int] = pydantic.Field(default=None)
    """
    Final number of chunks after merging
    """

    use_decomposition: typing.Optional[bool] = pydantic.Field(default=None)
    """
    Decompose complex queries
    """

    use_reformulation: typing.Optional[bool] = pydantic.Field(default=None)
    """
    LLM reformulates query
    """

    synthesize_response: typing.Optional[bool] = pydantic.Field(default=None)
    """
    LLM generates answer vs raw chunks
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow
